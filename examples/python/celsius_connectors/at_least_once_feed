#!/usr/bin/env python

import ctypes
from struct import unpack
import time

from wallaroo.experimental import (
                                   connector_wire_messages as cwm,
                                   AtLeastOnceSourceConnector,
                                   ProtocolError,
                                   ConnectorError)


class BaseIter(object):
    def throw(self, type=None, value=None, traceback=None):
        raise StopIteration

    def __iter__(self):
        return self

    def next(self):
        return self.__next__()

    def __next__(self):
        raise NotImplementedError


class FramedFileReader(BaseIter):
    def __init__(self, filename):
        self.file = open(filename, mode='rb')
        self.name = filename

    def __str__(self):
        return ("FramedFileReader(filename: {}, closed: {})"
                .format(self.name, self.file.closed))

    def point_of_ref(self):
        try:
            return self.file.tell()
        except:
            return -1

    def reset(self, pos=0):
        self.file.seek(pos)

    def __next__(self):
        # read header
        h = self.file.read(4)
        if not h:
            raise StopIteration
        h_bytes = unpack('>I', h)[0]
        b = self.file.read(h_bytes)
        if not b:
            raise StopIteration
        return (b, self.file.tell())

    def close(self):
        self.file.close()

    def __del__(self):
        try:
            self.close()
        except:
            pass


class MyFileReaderConnector(AtLeastOnceSourceConnector, BaseIter):
    def __init__(self, args=None, required_params=[], optional_params=[]):
        AtLeastOnceSourceConnector.__init__(self, args, required_params,
                                            optional_params)
        self.sources = {} # stream_id: source instance
        self.keys = []
        self._idx = -1

    def stream_updated(self, stream):
        print("MyFileReaderConnector.stream_updated")
        super(MyFileReaderConnector, self).stream_updated(stream)
        source = self.sources.pop(stream.id, None)
        # stream already in sources
        if source:
            # if stream is closed, close the file, then remove the source
            if not stream.is_open:
                source.close()
                # don't put it back in sources...
            # otherwise... check if you need to reset its position
            else:
                if stream.point_of_ref != source.point_of_ref:
                    source.reset(stream.point_of_ref)
                # put it back
                self.sources[stream.id] = source
        # stream is new to us
        else:
            if stream.is_open:
                # This is an error for MyFileReaderConnector
                raise ConnectorError("Can't open a new source from a stream. "
                                     "Please use the add_source interface.")
            # nothing to do with a closed stream for which there is no source

    def add_source(self, source):
        # add the self.sources
        _id = self.get_id(source.name)
        self.sources[_id] = source
        self.keys.append(_id)

        # send a notify
        self.notify(_id, source.name, source.point_of_ref())

    @staticmethod
    def get_id(text):
        """
        Get a positive U64 from the I64 of the hash of text
        """
        return ctypes.c_size_t(hash(text)).value

    # Make this class an iterable:
    def __next__(self):
        if len(self.keys) > 0:
            try:
                # get next position
                self._idx = (self._idx + 1) % len(self.keys)
                # get key of that position
                key = self.keys[self._idx]
                # get source at key
                source = self.sources[key]
                # get value from source
                value, point_of_ref = next(source)
                # send it as a message
                msg = cwm.Message(
                    stream_id = key,
                    flags = 0,
                    message_id = point_of_ref,
                    message = value)
                self.write(msg)
                return msg
            except StopIteration:
                # if he source threw that, send an EOS message on it
                self.write(cwm.Message(
                    stream_id = key,
                    message_id = source.point_of_ref(),
                    flags = cwm.Message.Eos))
                # then remove it from sources and close it
                source.close()
                del self.sources[key]
                self.keys.pop(self._idx)
                self._idx -= 1 # to avoid skipping in the round-robin sender
                return source
        else:
            raise StopIteration


hello = cwm.Hello("0.0.1", "1234", "celsius at least once", "instance")
args = ['--application-module', 'celsius',
        '--connector', 'celsius_feed',
        '--celsius_feed-host', '127.0.0.1',
        '--celsius_feed-port', '7100',
        '--celsius_feed-timeout', '0.05',
        '--celsius_feed-filenames', 'celsius.msg']
client = MyFileReaderConnector(
        args=args,
        required_params=['host', 'port', 'filenames'],
        optional_params=['timeout', 'delay'])
client.initiate_handshake(hello)
client.start()

params = client.params
filenames = params.filenames.split(',')
if params.delay:
    delay = float(params.delay)
else:
    delay = 0.001


# Open FramedFileReader
for fn in filenames:
    client.add_source(FramedFileReader(filename = fn))

# Wait for notifies to trickle in via `stream_updated`
time.sleep(1)

# Rely on the iterator method of our connector subclass
while True:
    try:
        msg = next(client)
        if isinstance(msg, FramedFileReader):
            print("Closed and removed {}".format(msg))
        else:
            print("Sent the message: {}".format(msg))
        time.sleep(delay)
    except ProtocolError as err:
        if err.message.contains("notify"):
            time.sleep(0.5)
        raise

time.sleep(1)
print("Client ran out of file data to send. Shutting down.")

# TODO:
# 1. fix cwm.Message flags checking logic
# 2. Fix the __str__ methods in cwm to always use `{!r}`
# 3. Update the unit tests to reflect those changes.
